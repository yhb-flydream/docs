# 网络部分

## 同步/异步&阻塞/非阻塞

参考
[【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）](https://www.cnblogs.com/lixinjie/p/10811219.html)
[深入理解并发 / 并行，阻塞 / 非阻塞，同步 / 异步](https://juejin.im/entry/58ae4636b123db0052b1caf8)
[怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473/answer/14413599)

> 代码发起一个HTTP请求后，就卡住不动了，这个请求是一个同步请求吗，为什么？
>
> 是同步请求，但不是因为代码卡住不动了才叫同步请求，而是因为它是同步请求所以代码才卡住不动了。
> 至于为什么能卡住不动，这是由操作系统和CPU决定的：
> 因为内核空间里的对应函数会卡住不动，造成用户空间发起的系统调用卡住不动，继而使程序里的用户代码卡住不动了。

### 同步/异步

- 同步/异步，关注的是**能不能同时动**

多个事物不能同时进行，必须一个一个的来，上一个事物结束后，下一个事物才开始。上一个事物还没结束的时候，其它事物都处于“等待”状态。多个事物是一种逐个逐个的串行化关系，绝对不会出现交叉的情况。

关于同步还需知道两个小的点：

- 一是范围，并不需要在全局范围内都去同步，只需要在某些关键的点执行同步即可。
- 二是粒度，并不是只有大粒度的事物才有同步，小粒度的事物也有同步。（只不过小粒度的事物同步通常是天然支持的，而大粒度的事物同步往往需要手工处理。）

### 阻塞/非阻塞

- 阻塞/非阻塞，关注的是**能不能动**

> 同步阻塞调用：得不到结果不返回，线程进入阻塞态等待。
> 同步非阻塞调用：得不到结果不返回，线程不阻塞一直在CPU运行。
> 异步阻塞调用：去到别的线程，让别的线程阻塞起来等待结果，自己不阻塞。
> 异步非阻塞调用：去到别的线程，别的线程一直在运行，直到得出结果。

## 并发/并行

> 并发是指一个时间段内，有几个程序都在同一个CPU上运行，但任意一个时刻点上只有一个程序在处理机上运行。
> 并行是指一个时间段内，有几个程序都在几个CPU上运行，任意一个时刻点上，有多个程序在同时运行，并且多道程序之间互不干扰。

## 进程/线程

参考
[进程与线程的一个简单解释](https://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)

## 递归/迭代

参考
[递归与迭代的区别](https://www.jianshu.com/p/32bcc45efd32)
[「递归」和「迭代」有哪些区别？](https://www.zhihu.com/question/20278387)
[深究递归和迭代的区别、联系、优缺点及实例对比](https://blog.csdn.net/laoyang360/article/details/7855860)

### 递归

递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在**自身调用自身**的方法。（A调用A）

递归是一个**树结构**，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。

```js
function recursive(data, arr = []) {
  arr.push(data.id)
  if (data.child) {
    recursive(data.child, arr)
  }
  return arr
}
```

**优点：**

- 大问题化为小问题,可以极大的减少代码量
- 可以用有限的语句来定义对象的无限集合
- 代码更简洁清晰，可读性更好

**缺点：**

- 递归调用函数，浪费空间
- 递归太深容易造成堆栈的溢出

**注意：**

- 在使用递归时，必须有一个明确的递归结束条件，称为递归出口
- 递归太深容易造成堆栈的溢出

### 迭代

重复反馈过程的活动，**每一次迭代的结果会作为下一次迭代的初始值**。（A重复调用B）

迭代是一个**环结构**，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。

```js
function iteration(x){
  var sum=1;
  for(x; x>=1; x--){
    sum = sum*x;
  }
}
```

**优点：**

- 迭代效率高，运行时间只因循环次数增加而增加
- 没什么额外开销，空间上也没有什么增加

**缺点：**

- 不容易理解
- 代码不如递归简洁
- 编写复杂问题时困难

### 分析

- 理论上递归和迭代时间复杂度方面是一样的，但实际应用中（$\underline{函数调用和函数调用堆栈的开销}$）**递归比迭代效率要低**。
- 递归中一定有迭代，但是迭代中不一定有递归，大部分可以相互转换。
- 能用迭代的不用递归，递归调用函数，浪费空间，并且递归太深容易造成堆栈的溢出。

### 区别

#### 遍历、循环和迭代

**相同：**

- 都会有**多次操作**

**不同：**

- 遍历是**依次**对集合中的每个元素**做且仅做**一次访问
  - 依次，代表具有某种顺序。
  - 比如二叉树有三种前序、中序、后序遍历。数组有顺序、逆序遍历等等。
- 循环侧重于描述每次操作和上一次操作的**相同**之处
  - 比如一个 for 循环，其中的逻辑每次执行都相同，我们可以说它是一个循环
- 迭代侧重于描述每次操作和上一次操作的**不同**之处
  - 每次操作都会跟上一次不一样，或是有了新的目标，或是缩小了搜寻范围

https://juejin.im/post/5e9cda81e51d4547092219fa
https://juejin.im/post/5da18b1af265da5bb318ed07
https://juejin.im/post/5da985fae51d4525292d3145
https://juejin.im/user/5874526761ff4b006d4fd9a4/posts
https://github.com/ljianshu/Blog
https://github.com/woai30231/http
https://zhuanlan.zhihu.com/p/20346379