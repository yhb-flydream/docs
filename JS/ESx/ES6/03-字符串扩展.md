# 字符串扩展

## 字符的 Unicode 表示法

ES6 加强了对 `Unicode` 的支持，允许采用 `\uxxxx` 形式表示一个字符，其中 `xxxx` 表示字符的 `Unicode` 码点。

```js
'\u0061'
// "a"
```

但是，这种表示法只限于码点在`\u0000~\uFFFF` 之间的字符。超出这个范围的字符，必须用两个**双字节**的形式表示。

```js
'\uD842\uDFB7'
// "𠮷"

'\u20BB7'
// " 7"
```

上面代码表示，如果直接在 `\u` 后面跟上超过 `0xFFFF` 的数值（比如`\u20BB7`），JavaScript 会理解成`\u20BB+7`。由于 `\u20BB` 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 `7`。

## 字符串的遍历器接口

ES6 为字符串添加了遍历器接口，使得字符串可以被 `for...of` 循环遍历。

```js
for (let codePoint of 'foo') {
  console.log(codePoint)
}
// "f"
// "o"
// "o"
```

## 直接输入 U+2028 和 U+2029

## JSON.stringify() 的改造

根据标准，`JSON` 数据必须是 `UTF-8` 编码。但是，现在的 `JSON.stringify()` 方法有可能返回不符合 `UTF-8` 标准的字符串。

具体来说，`UTF-8` 标准规定，`0xD800` 到 `0xDFFF` 之间的码点，不能单独使用，必须配对使用。
比如，`\uD834\uDF06` 是两个码点，但是必须放在一起配对使用，代表字符 `𝌆`。这是为了表示码点大于 `0xFFFF` 的字符的一种变通方法。单独使用 `\uD834` 和 `\uDFO6` 这两个码点是不合法的，或者颠倒顺序也不行，因为 `\uDF06\uD834` 并没有对应的字符。

`JSON.stringify()` 的问题在于，它可能返回 `0xD800` 到 `0xDFFF` 之间的单个码点。

```js
JSON.stringify('\u{D834}') // "\u{D834}"
```

为了确保返回的是合法的 `UTF-8` 字符，ES2019 改变了 `JSON.stringify()` 的行为。如果遇到 `0xD800` 到 `0xDFFF` 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。

```js
JSON.stringify('\u{D834}') // ""\\uD834""
JSON.stringify('\uDF06\uD834') // ""\\udf06\\ud834""
```

## 模板字符串 `

反引号 (`)

- 模板字符串中使用变量 **\${}**
- 在模板字符串中需要使用反引号，则前面要用反斜杠转义 `\`Yo\` World!`
- 所有的空格和缩进都会被保留在输出之中
- 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性 `${x} + ${y * 2} = ${x + y * 2}`
- 调用函数
- 如果大括号内部是一个字符串，将会原样输出
- 模板字符串甚至还能嵌套

## 标签模板

## 模板字符串的限制
