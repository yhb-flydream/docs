# JS

[TOC]

- 特点：
  - 封装
  - 继承
  - 多态
- 写法：
  - 内嵌
    - 用内嵌式写法，推荐位置放在 body 标签之外
  - 外链
    - 新建.js 文件
    - 调用 `<script type="text/javascript" src="index.js"></script>`
    - 如果调用了多个 js 文件，最好能将 js 文件合并到一个文件中

```text
window.onload = function() {
  内部放js
}
【当页面加载完毕以后，才去执行这里面的js内容，就是说等页面的结构、样式、节点等加载完】
```

**js 中常见消息提示方式：**

- `alert`——(弹窗显示消息)
  - `alert("内容");`
  - **注意：**如果页面上出现弹窗以后，页面位置不能关闭，也不能改变。浏览器进程已经被暂停
- `// | /* */`——（注释）
- `document.write`——直接在页面输出消息
  - `document.write("内容");`
  - 内部可写 html 标签【`document.wtite("<h1>内容</h1>");`】
- `prompt`——弹出输入框，用来接收用户输入的内容
  - `prompt("提示内容");`
  - **接收到的数据类型为 string 类型**
- `console.log()`——在控制台输出内容
  - **用来进行代码调试**
- `confirm("")`——显示消息
  - 一般与条件判断配合使用
- `console.warn("")`——控制台警告
- `console.error("")`——控制台错误提示

### 变量

> 会变化的数据
> 用来存储数据的容器

- **定义**：

  - 使用 var 关键字定义变量
  - 【`var 变量;`】 定义变量
  - 【`变量="内容";`】 给变量赋值
  - `var 变量="内容"` 定义变量并给变量赋值

- **命名规范：**

  - 字母大小写有区别
  - 不能用纯数字定义变量，或以数字开头
  - 可用汉字定义变量（不推荐）
  - 不能使用特殊字符定义变量，或以特殊字符开头（下横线除外“\_”）
  - 不能使用关键字定义变量
  - 不能使用保留字定义变量【保留字：备用的关键字】
  - 一个变量只能保存一个值，如果同一个变量被再次赋值，则保存的值是最后定义的值
  - 变量名中间不能出现空格

- **分类**[所有数据类型原始类型都是数组]
  - **一、数字类型（number）**如果一个变量的值是数字（小数，整数，负数），当前变量的类型都是数字类型
    - 1、数字类型表示方式
      - 最常见是十进制（`var n1=123;`）
      - 十六进制 以 0x 开头，0-9 和 a(A)-f(F)组成
      - 八进制 以数字 0 开头，0-7 组成
  - **二、字符串类型（string）**
    - 1、如果一个变量的值是使用“双引号”或‘单引号’包括起来的，那么该变量的类型为字符串类型
    - 2、字符串中的转义字符
      - `\"` 代表一个双引号
      - `\'`代表一个单引号
      - `\r`回车
      - `\n`换行
      - `\t`缩进
  - **三、布尔类型（boolean）**
    - 1、只有两个值 `true和false`
  - **四、变量未初始化（undefined）**
    - 定义了一个变量但未赋值，则这个变量默认为 undefined，
    - 对应的类型为 undefined 数据类型

**比较运算符：**

> 通过比较运算符得出的结果为布尔类型

**算术运算符**

> `+ | - | * | / | %(取余) | ()优先级`

- **一、加**
  - 1、如果两个数据类型都为数字类型，则结果为两个数字类型的和
  - 2、如果两个数据为非数据类型的变量相加，则最后结果为一个字符串。`+`起了链接作用
- **二、减法**
  - 1、如果两个数据类型都为数字类型，则结果为两个数字类型的差
  - 2、如果有一个是数字类型的字符串相减，最后结果仍为数字（减运算作用为数据的隐式类型转换）
  - 3、如果是非数字类型的变量相减，最后的结果为 NaN(not a number)
- **三、除**

  - 1、如果两个数据类型都为数字类型，则结果为两个数字类型的商
  - 2、如果有一个是数字类型的字符串相除，最后结果为数字（除运算作用为数据的隐式类型转换）
  - 3、如果一个数字除以 0，得到的结果为`infinity`（无穷大）
  - 4、如果是非数字类型的变量相除，最后的结果为`NaN(not a number)`

- **数据类型**
  - 用来确定变量在内存中的存在形式
- **数据类型判断：**
  - 【`typeof(变量/直接量) 或 typeof 变量/直接量`】获取当前变量的数据类型
  - 【`NaN(not a number) 数据类型为number`】 表示数值的不正常状态，在计算错误是出现
  - 【`infinity`（无穷大） 数据类型为 number】
  - 【`isNaN()是 不是一个数字`】是数字时为 false、是非数字时为 true

### Math 对象

- `Math.ceil();`
  - 【向上取整】 天花板函数
  - 返回值为大于当前数字最接近的整数
- `Math.floor();`
  - 【向下取整】 地板函数
  - 返回值为小于当前数字最接近的整数
- `Math.max(放入需要比较的内容[可有多个数值]);`
  - 获取最大值
- `Math.min(放入需要比较的内容[可有多个数值]);`
  - 获取最小值
- `Math.abs();`
  - 返回一个数字的绝对值
- `Math.pow(数字，指数);`
  - 求一个数字的几次方
- `Math.random();`
  - 返回随机数 0-1 之间(不包括 0 和 1)
- `Math.round();`
  - 返回四舍五入值

---

#### 类型转换：

- **隐式类型转换：**

  - 变量参与到运算过程中，实现的数据类型转化（没有程序员参与）
  - **隐式转换为 Number**
    - `+ - * /` 都可以
    - 直接在要转换的内容前加`"+"`，内容与`"+"`中间无空格
  - **隐式转换为 String**
    - 在数据后加 `""`

- **强制类型转换：**
  - 程序员手动设置的数据类型转换
  - **转换为字符串类型**
    - `String("要转换的内容");`
      - 【none、undefined，用 string 变换】
    - `变量.toString("要转换的内容");`【其他都可用`.tostring`变换】
  - **转换为数字类型**
    - `Number("要转换的内容");`
      - 可以将数字内容的字符串转换为数字类型，
      - 如果不能转换则返回 NaN;
      - 如果有小数位，则保留小数位
      - 如果内容为空，则返回 0
    - `parseInt("要转换的内容",进制);`
      - 【加进制后，要转换的内容为对应的进制的值 输出值为十进制】
      - 可以将数字内容的字符串转换为数字类型，
      - 如果不能转换则返回 NaN;
      - 如果有小数位，则只保留整数位，省略小数位，（不是四舍五入）
      - 如果第一个字符是数字，则继续解析直至字符串解析完毕或遇到一个非数字符号为止
      - 如果内容为空，则返回 0
    - `parseFloat("要转换的内容");`
      - 可以将数字内容的字符串转换为数字类型
      - 可以完全保留原来的内容(保留小数位)
  - 转换为布尔型
    - `Boolean("要转换的内容");`
      - true 在内存中以 1 形式存在
      - false 在内存中以 0 形式存在
    - 通过数据类型转换后，可以将数字 0 和 false 相互转换
    - 除了`0、 ""、NaN、Undefined、null`这几个再转换时转换成 false 之外，其他内容都转换为 true（包括字符串的"false"）
    - **隐式布尔转换：if（）、！！**

**等号运算符：**

- `“=”` 赋值运算符
- `“==”` 判断是否相等
  - 判断的是`数据内容`是否相等，不管数据类型
- `“===”` 判断是否全相等
  - 判断的是`数据内容和数据类型`是否相等
- `“!=” `不等于
  - 判断的是`数据内容`是否不相等，不管数据类型
  - 如果内容相等返回 false， 如果内容不相等返回 true
- `“!==”` 全不等于
  - 判断的是`数据内容和数据类型`是否不相等
  - 数据只要内容或类型不一样就返回 true，反之为 false

**运算优先级**

- `（）`
- 一元运算符 `++、--、！`
- 算术运算符 `先*、/、%，后+、-`
- 关系运算符 `>=、>、<=、<`
- 相等运算符 `==、！=、===、！==`
- 逻辑运算符 `！，&&，||`

**使用逗号可以集体声明变量（省略的繁复的声明）**

**逻辑运算符：**

- 或-----> `||`
  - 只要有一个条件满足为 true，结果就为 true
  - ||碰到 true 会短路，返回第一个值
- 且-----> `&&`
  - 条件必须同时满足 true，结果才为 true
  - &&碰到 false 会短路，返回第一个值
- 非-----> `!` (取反)
  **优先级：`！> && > ||**

**字符串类型用||运算符，如果有值为 true 的字符串，则返回第一个值为 true 的字符串内容，如果都为 false，则返回最后一个为 false 的内容**

**三元表达式：**

- `表达式？ 代码1 ： 代码2；`
  - 如果表达式为 true，执行冒号前代码 1，否则冒号后执行代码 2

**switch case：**

- switch 后的数据类型，必须和 case 后的数据类型一致

```
var 变量=
switch(){
  case1 变量的值1：
    代码块1；
    break；
  case2 变量的值2：
    代码块2；
    break；
  case3 变量的值3：
    代码块3；
    break；
  case4 变量的值4：
    代码块4；
    break；
  ...
  default:
    默认代码块；
    break；
}
```

**循环语句 while**

- **先判断，再循环。适用于不明确循环次数的情况下**
- **特点：**可以重覆完成同样的事情
- 当程序运行到 while 时，判断条件语句，如果为 true，执行下面的代码，如果为 false，则跳过 while

```
while(条件语句、布尔值){
  重复执行的代码块；
}
```

**do while**

- **先循环，在判断**
- **特点：**先执行 do 里面的代码循环，再经过 while 语句的判断，如果满足条件，继续循环，如果不满足，则终止循环 **【至少执行一次】**
- 如果条件不成立的情况下，do while 循环，比 while 循环多执行一次

```
do {
  重复执行的代码块；
}while(条件语句、布尔值)
```

**for**

```
for (var i = 0; i < length; i++) {
  循环代码块；
}
```

### 数组

- **定义：**
  - 1、通过对象的方式创建数组 `var ary[数组名]=new Array(内容为一个数时为长度、 内容为一个带引号的内容时为第一项的值、 内容为用“ ，”隔开的内容时为数组内容);`
  - 2、直接创建数组 `var ary1=[]; `【[]数组的字面量】
- 设置默认值：
  - 1、`var ary=new Array(值1，值2，值3，...);` 【值可以是任何数据】
  - 2、`var ary=[值1，值2，值3，...];` 【值可以是任何数据】`（推荐使用）`
- **赋值：**
  - 【数组中下标是从 0 开始的，0 代表第一个值】赋值时需要通过下表设置值

```
var arr = [];
arr[0] = 值1;
arr[1] = 值2;
arr[2] = 值3;
...
```

- **取值：**

```
console.log(arr[0]);
```

- **遍历：**
  - 前提知道数组有多少值（长度）
  - 通过`length`获取或设置元素的个数
  - `arr.length` 获取数组的长度
  - `arr[i].length` 获取数组中某个字符串的长度

```
for (var i = 0; i < arr.length; i++) {
  concole.log(arr[i]);
}
```

**数组中的方法：**

- `push()`
  - 向数组`末尾`添加一个或多个元素，并`返回数组的长度`
  - `ary.push(元素,元素,元素...);`
  - 返回值为把元素推入数组后的长度
- `unshift()`
  - 从数组`前面`放入一个或多个元素，并`返回数组的长度`
  - 返回值为把元素推入数组后的长度
- `pop([内无参数])`
  - 删除数组`最后一个元素`，返回值为数组最后一个已经被删除的元素
- `shift([内无参数])`
  - 删除数组第一个元素，返回值为数组第一个已经被删除的元素
- `arr.join("符号[可省略]")`
  - 变换数组中元素之间的链接方式，为空时为默认值“，” `【返回一个字符串类型】`
- `str.split("符号[可省略]","howmany[一般不写]")`
  - 把字符串转换成数组，为空时为默认值“，”`【返回一个数组类型】`
  - **split("符号[可省略]")中的符号必须和字符串中的连接符保持一致，才能变换符号为`逗号(,)`**
- `concat()`
  - 例：`arr1.concat(arr2);`
  - 将数组合并，不会改变当前数组
  - 合并产生的是一个`【新数组】`
- `slice()`
  - 例：`slice(begin,[end]);`
  - 参数 1：开始位置 参数 2：结束位置，可选
  - 截取指定数组中的值，存入一个新的数组中,合并产生的是一个`【新数组】`
  - **注意：**
    - 1.slice 方法截取数组只包含 begin，不包含 end。
    - 2.slice 方法的参数可以是负数，表示从后面往前数第几个元素，（慎用，容易搞混）
    - 3.slice 方法不会影响到原来的数组
- `splice()`
  - 例：`splice(start, deleteCount, [items]);`
  - 参数 1：开始位置
  - 参数 2：删除的个数
  - 参数 3：需要替换的数组【如果参数 3 没有传，那么只会删除数组对应的元素】
  - 先删除指定数目元素，再添加入替换的元素
  - **改变了原来的数组**
- `indexOf()`
  - `indexOf(searchElement, [fromIndex])`
  - 查找数组中元素出现的位置

#### 函数（方法）：

> 函数是有事件驱动的或者当它被调用时执行的`可重复使用的代码块` > **函数名.length**得到函数形参的个数

- **三要素：**
  - 功能
  - 参数
  - 返回值
- **定义：**
- 1、【函数声明】

```
function 函数名(参数1， 参数2， 参数3...) {
  函数体；
}
函数名(); <————函数的调用（可写在声明前面）
```

- 2、【函数表达式（匿名函数）】

```
var 函数名 = function(参数1， 参数2， 参数3...){
  函数体；
}
函数名(); <————函数的调用（必须写在后面）
```

- 3、【自调用函数（自能执行一次）】

```
(function(){
  函数体；
})();
```

**arguments（存放函数实参变量） `arguments.length`(实参个数)**

**`fn.length`【形参个数】**

**return:**

- 一个函数实际上就是一个计算的过程，计算完之后的结果就是返回值 **位置写在计算完成之后**
- 定义函数的返回值：
  - 在函数内部使用 return 设置返回值，一个函数只有一个返回值
  - 返回值的同时，结束代码
  - 所有自定义函数默认没有返回值
  - return 之后不要加换行
  - return 之后加了内容，则返回 return 之后的内容
  - return 之后不加任何东西，返回值为 undefined
  - 如果函数内部没有写 return 时返回值为 undefined

**javascript 没有重载概念**

- 在其他语言中，有`重载`概念`【函数的名字相同，但参数个数不同】`
- 如果定义了两个相同的函数，那么后面的函数会覆盖掉前面的函数【在 javascript 中不允许出现同名的函数】

**变量作用域：**

- 当变量超出作用域之后变量将被销毁
- **全局变量：**
  - 1、在最外层声明的变量（有无 var 都是全局变量）
  - 2、在函数体内部，但是没用 var 声明的也是全局变量【隐式全局变量】
- **隐式全局变量：**
  - 在函数体内部，但是没用 var 声明的也是全局变量
- **局部变量【函数作用域】**
  - 【局部变量优先级较高】
  - 1、在`函数体内部`使用 var 声明的变量
  - 2、超出函数作用范围之后局部变量被销毁

**没有块级作用域**

- if 和 for 中使用的 var 变量都是全局变量

### 事件三要素

- 事件源 ：被触发者 一般情况下是名词
- 事件 ：做了什么 一般情况下是动词 【点击、鼠标经过、按键盘】
- 事件处理程序 ： 发生了什么

```
事件源.函数(onclick) = function（）{
  事件处理函数
}
```

**递归：**

> 方法自身调用，一般还要有结束的条件

### 对象：

```
var obj = {};
```

- 指的是一个具体的东西
- 有`行为` 和 `特征`
- **特征：**
  - 用 **属性** 来表示 **用定义（var）**
- **行为：**
  - 用**方法**来表示 为匿名函数（function）
- 用`for(var key in obj){}`遍历对象，得到对象的属性和 e

# JavaScript 复习

[TOC]

## 1、基本组成

- ECMAScript
- DOM
- BOM

## 2、数据类型

| 基本数据类型 | 复杂数据类型 |
| ------------ | ------------ |
| number       | object       |
| string       |
| null         |
| undefined    |
| boolean      |

#### ECMAjavascript 内置对象

- Array
- Math
- String
- Object
- Date
- Number
- Boolean
- Error
- Function
- RegExp

#### 如何判断数据类型

- **`typeof`**
  - type of 无法判断 null 的数据类型，反过来说是 typeof 判断 object 的类型有误
  - type of 可以判断 function 类型的对象
  - 运算结果的返回值有：
    - 'object'
    - 'string'
    - 'number'
    - 'boolean'
    - 'function'
    - 'undefined'
- instanceof

```
//关于instanceof 的一些继承结构的试题
// new Date ==> Date.prototype ==> Object.prototype ==>null

console.log(new Date instanceof Function);  //f------
console.log(new Date instanceof Object); //t
// console.log(new Array instanceof Function); //f
// console.log(new String instanceof Function); //f

// new Function ==> Function.prototype ==> Object.prototype ==>null

console.log(new Function instanceof Function); //t
console.log(new Function instanceof Object); //t

// Number ==> Function.prototype ==> Object.prototype ==>null

console.log(Number instanceof Function); //t
console.log(Number instanceof Object);  //t

// Function ==> Function.prototype ==> Object.prototype ==>null

console.log(Function instanceof Function); //t
console.log(Function instanceof Object); //t

// Object ==> Function.prototype ==> Object.prototype ==>null

console.log(Object instanceof Function);  //t
console.log(Object instanceof Object); //t
```

## 3、基本类型与引用类型的赋值问题

#### 基本类型(值类型)

- 赋的是 copy 的具体值

```
var a = 1;
var b = a;
```

#### 引用类型(复合类型)

- 赋的是对象的地址

```javascript
var obj = {
  value: 100,
}
var obj2 = obj // 把obj的地址赋值给obj2
obj2.value = 1 // obj 和obj2指向同一地址 obj.value = 1 就改变了他们指向的同一个对象的值
console.log(obj.value) //输出value = 1

/*-------------------------------------------------------------*/

var obj = {
  value: 100,
}
var obj2 = obj // 把obj的地址赋值给obj2 现在obj 和 obj2指向同一地址
obj = {} // 赋值以后，把新对象的地址赋值给obj obj指向了新的地址，obj2还是指向以前的地址
console.log(obj2) // obj2地址没有变化 输出{value ： 100}
```

## 4、运算符

#### 算术运算符

- \+ 算术运算、字符串拼接、转换数据类型为 number 类型
- % 取余运算

#### 逻辑运算符 && -- || -- ！

- && 从左往右依次把数据转换伪 boolean 类型，如果是`false`，则返回具体的数据；如果一直没有找到，则返回最后一个**数据**
- || 从左往右依次把数据转换伪 boolean 类型，如果是`true`，则返回具体的数据；如果一直没有找到，则返回最后一个**数据**
- ！把数据转换为 boolean 类型，然后取反

#### 相等运算符 == === != !==

- === 判断数据和类型必须全部相等

- == 会先进行数据转换，然后再比较

> \*\*约定：非空数据类型表示除了`null`和`undefined`两种数据类型。

- 任何数据和 NaN 相比结果都为 false
- null 等于 undefined
- null 和非空类型相比结果为 false
- undefined 和非空类型相比结果为 false
- 数字和非空类型比较，先转换为数字再比较
- 布尔和非空类型比较，先转换为数字再比较
- 对象与对象比较内存地址
- 对象与字符串，对象先转换为字符串再比较

| 类型      | 类型      | 规律               |
| --------- | --------- | ------------------ |
| NaN       | 任意类型  | false              |
| null      | undefined | true               |
| null      | 非空类型  | false              |
| undefined | 非空类型  | false              |
| 数字      | 非空类型  | 转换为数字再比较   |
| 布尔      | 非空类型  | 转换为数字再比较   |
| 对象      | 对象      | 内存地址比较       |
| 对象      | 字符串    | 转换为字符串再比较 |

#### 三元运算符（ ? :）

##### ? 前面的表达式为 true，执行 : 前的表达式；否则执行 : 后的表达式

## 5、布尔类型转换

#### 如何把数据转换为布尔类型

- !!
- Boolean

#### 哪些数据类型转换为 boolean 类型时为 false

- 0
- undefined
- null
- ""
- NaN

## 6、语句

#### 分支语句

- if else
- switch case

#### 循环语句

- for
- while
- do while
- for in

#### break 和 continue

- break 结束循环
- continue 跳出当前循环，继续下次循环

## 7、函数

#### 创建函数方式

- 1、函数声明
  - 全局，最后无分号`(;)`

```javascript
function Fn() {
  代码块
}
Fn() //写在前后都可以
```

- 2、函数表达式(函数字面量)
  - 凡是将数据和运算符等联系起来，有值的式子就是表达式
  - 表达式和符号结合起来就是语句
  - **声明式函数不允许出现在表达式中**

```javascript
var fn = function () {
  代码块
}
fn() //必须写后面
```

- 3、new Function

#### 参数

- 对函数中重复执行代码中的不同部分的抽象提取
- 形参是用来接收实参传递过来的值

#### 返回值

- 如果没有 return 语句，则为 undefined；
- 如果有则为对应的值

#### arguments

- 是一个可以在函数中使用的关键字
- 是一个代表实参的对象
- 可以通过下标的方式获取实参`arguments[n]`
- 可以通过`length`属性获取实参的个数
- 像这种拥有`length`属性，以下标存储数据的对象，统一称之为伪数组。
- 作用：
  - 可以判断传入的实参和形参个数是否相等
- 模拟重载
  - 在 jQuery 中应用广泛

```
function fn( ) {
  var arg = arguments, argLen = arg.length;

  if ( !argLen ) {
    console.log('请重新输入！');
  }else if ( argLen === 1 ) {
    console.log( arg[0] );
  }else if( argLen === 2 ) {
    console.log( arg[0] + arg[1] );
    }else {
        console.log('最多输入两个数！');
    }
}

fn();
fn(1);
fn(10,20);
fn(10,20,30,40);
```

#### 重载

- 函数或者方法有相同的名称，但是参数列表不相同

#### this

- 函数中的 this 谁调用就指向谁

#### 错误抛出

- throw 自定义抛出错误

```
function con( par ) {
    if ( par == null ) {//判断传入参数如果为null或undefined，则输出报错信息
        throw '参数错误！' + par;
    }
    console.log( par );
}
con(null);//报错，下面代码不执行
con(undefined);
con(111);
con('acb');
```

#### debugger 与断点

- 写入代码块中，当浏览器执行时，从当前位置开始调试

#### in 运算符

- 判断对象中是否有这个属性
  - 语法：`"str" in Object`
  - 返回值为 boolean 类型

#### delete 运算符

- 返回值为`boolean`类型
- 语法：`delete 数据;`
- 在当前作用域上删除数据
- 用法：
  - 删除数组中的一个元素
    - 不改变数组的长度
    - 删除的数据变成了 undefined
  - 删除一个对象的属性或方法
  - 删除一个`没有用的var 声明`的变量

#### try-catch

- 语法：

```javascript
try {
  //假如可能出现错误的代码
} catch (e) {
  //出现错误才会执行的代码,不设置内容也可以
} finally {
  // 可选
  //无论是否有异常，最后执行
}
```

- 使用：

- e(exception 异常)
  - 浏览器报出错误的信息是什么，e 就是什么
